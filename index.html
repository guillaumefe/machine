<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>V86</title>
  <style>
    html, body {
      background: black;
      margin: 0;
      padding: 0;
      color: #eee;
      font: 12px monospace;
      height: 100%;
      overflow: hidden;
    }
    #header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 24px;
      background: #222;
      display: flex;
      align-items: center;
      padding: 0 8px;
      z-index: 1000;
    }
    #header span { margin-right: 16px; }
    #screen_container {
      position: absolute;
      top: 24px; left: 0;
      width: 100%;
      height: calc(100% - 24px);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #screen_container canvas {
      width: 100%;
      height: 100%;
    }
    #v86_ui { position:absolute; width:0; height:0; overflow:hidden; }
  </style>
</head>
<body>
  <div id="header">
    <span>Memory : <b id="mem_ram">‑ MB</b></span>
    <span>IndexedDB : <b id="idb_usage">‑ MB</b></span>
    <span>Net In : <b id="net_in">‑ KB</b></span>
    <span>Net Out : <b id="net_out">‑ KB</b></span>
  </div>
  <div id="screen_container"></div>
  <div id="v86_ui">
    <button id="start_emulation"></button>
    <button id="run"></button>
    <button id="pause"></button>
    <button id="reset"></button>
    <button id="upload"></button>
    <button id="dump_log"></button>
    <button id="dump_pt"></button>
    <button id="ctrlaltdel"></button>
    <button id="alttab"></button>
    <button id="get_fda_image"></button>
    <button id="get_fdb_image"></button>
    <button id="screenshot"></button>
    <button id="save_user_state"></button>
    <button id="restore_user_state"></button>
    <button id="download_fat_binary"></button>
    <button id="fullscreen"></button>
    <input type="file" id="disk_image_file">
    <input type="url" id="disk_image_url">
    <button id="load"></button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="build/v86_all.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      let netIn = 0, netOut = 0;
      // Fetch instrumentation
      const origFetch = window.fetch;
      window.fetch = async function(...args) {
        if (args[1]?.body) {
          const b = args[1].body;
          netOut += typeof b === "string" ? b.length : (b.byteLength || 0);
        }
        const response = await origFetch.apply(this, args);
        response.clone().arrayBuffer().then(buf => netIn += buf.byteLength).catch(() => {});
        return response;
      };
      // XHR instrumentation
      const origXHRSend = XMLHttpRequest.prototype.send;
      XMLHttpRequest.prototype.send = function(body) {
        if (body) netOut += typeof body === "string" ? body.length : (body.byteLength || body.size || 0);
        this.addEventListener('loadend', () => {
          const r = this.response;
          if (r) netIn += typeof r === "string" ? r.length : (r.byteLength || r.size || 0);
        });
        return origXHRSend.apply(this, arguments);
      };
      // WebSocket instrumentation
      const OrigWS = window.WebSocket;
      window.WebSocket = function(url, protocols) {
        const ws = protocols ? new OrigWS(url, protocols) : new OrigWS(url);
        const sendOrig = ws.send;
        ws.send = function(data) {
          let size = 0;
          if (typeof data === 'string') size = new TextEncoder().encode(data).length;
          else if (data instanceof Blob) size = data.size;
          else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) size = data.byteLength;
          netOut += size;
          return sendOrig.call(this, data);
        };
        ws.addEventListener('message', event => {
          const d = event.data;
          let size = 0;
          if (typeof d === 'string') size = new TextEncoder().encode(d).length;
          else if (d instanceof Blob) size = d.size;
          else if (d instanceof ArrayBuffer || ArrayBuffer.isView(d)) size = d.byteLength;
          netIn += size;
        });
        return ws;
      };
      Object.assign(window.WebSocket, OrigWS);
      window.WebSocket.prototype = OrigWS.prototype;
      // Monitoring
      function updateStats() {
        const toMB = bytes => (bytes / 1024 / 1024).toFixed(1) + ' MB';
        const mem = performance.memory;
        if (mem) {
          const used = mem.usedJSHeapSize;
          const limit = mem.jsHeapSizeLimit || 0;
          document.getElementById('mem_ram').textContent = `${(used / 1048576).toFixed(1)} MB / ${(limit / 1048576).toFixed(1)} MB`;
        }
        navigator.storage?.estimate?.().then(e => {
          document.getElementById('idb_usage').textContent = toMB(e.usage || 0);
        });
        document.getElementById('net_in').textContent = (netIn / 1024).toFixed(1) + ' KB';
        document.getElementById('net_out').textContent = (netOut / 1024).toFixed(1) + ' KB';
      }
      setInterval(updateStats, 1000);
      updateStats();
      // Initialize swap DB
      indexedDB.open("v86_swap", 1).onupgradeneeded = e => {
        e.target.result.createObjectStore("pages");
      };
      // Launch emulator
      new V86({
        wasm_path: "build/v86.wasm",
        bios: { url: "build/bios/seabios.bin" },
        vga_bios: { url: "build/bios/vgabios.bin" },
        memory_size: 268435456,
        cdrom: { url: "slitaz-4.0-xorg-light-isohybrid.iso" },
        screen_container: document.getElementById("screen_container"),
        autostart: true,
        swap_async: true,
        swap_aggressive: true,
        use_page_cache: true,
        page_cache_size: 16,
        disable_memory_cow: true,
        network_relay_url: "wss://relay.widgetry.org",
        network_backend: "socket",
        pagefile_read(i, callback) {
          indexedDB.open("v86_swap").onsuccess = e => {
            const db = e.target.result;
            const tx = db.transaction("pages", "readonly");
            const store = tx.objectStore("pages");
            store.get(i).onsuccess = o => {
              const res = o.target.result;
              callback(res ? pako.inflate(new Uint8Array(res)) : new Uint8Array(4096));
            };
          };
        },
        pagefile_write(i, data, callback) {
          indexedDB.open("v86_swap").onsuccess = e => {
            const db = e.target.result;
            const tx = db.transaction("pages", "readwrite");
            const store = tx.objectStore("pages");
            store.put(pako.deflate(data), i).onsuccess = () => callback();
          };
        }
      });
      // Bind UI buttons
      "run reset dump_log ctrlaltdel alttab fullscreen dump_pt get_fda_image get_fdb_image screenshot save_user_state restore_user_state download_fat_binary load"
        .split(' ')
        .forEach(id => {
          const btn = document.getElementById(id);
          if (btn) btn.onclick = () => {};
        });
    });
  </script>
</body>
</html>

