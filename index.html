<!DOCTYPE html>
<html lang="fr">
   <head>
      <meta charset="UTF-8">
      <title>Chargement...</title>
   </head>
   <body>
      <script>
         (function(){
         
           //const ISO = "TinyCore-current.iso";
           //const ISO = "Core-current.iso";
           //const ISO = "slitaz-4.0-xorg-light-isohybrid.iso";
         
           const MEMORY_SIZE = 256 * 1024 * 1024; // 256 MiB
           let emulator;
           let fsWriteBytes = 0;
         
           // 1. Insérer style global
           const style = document.createElement("style");
           style.textContent = `
             html, body { background: black; margin:0; padding:0; color:#eee; font:12px monospace; }
             #header { position: fixed; top:0; left:0; width:100%; height:24px; background:#222; display:flex; align-items:center; z-index:1000; }
             #header span { margin:0 8px; }
             #screen_container { position:absolute; top:24px; left:0; width: 100vw; height:calc(100% - 24px);display: flex; }
             #screen { display: none; }
             #screen_container canvas {cursor:none; max-width:100%;max-height:100%;width:auto;height:auto;display:block;}
             #mem_wrapper {
               position: relative;
               display: inline-block;
             }
             #mem_tooltip {
               position: absolute;
               top: 1.5em; left: 0;
               background: rgba(50,50,50,0.9);
               color: #eee;
               padding: 4px 8px;
               border-radius: 4px;
               white-space: pre;
               font-size: 10px;
               display: none;
               z-index: 1001;
             }
             #mem_wrapper:hover #mem_tooltip {
               display: block;
             }
           `;
         
           document.head.appendChild(style);
           // 2. Titre
           document.title = "WASMSHELL";
         
           // 3. En-tête dynamique
           const header = document.createElement("div");
           header.id = "header";
           header.innerHTML = `
             <span id="mem_wrapper">
               Memory : <b id="mem_ram">- MB</b>
               <div id="mem_tooltip">Loading…</div>
             </span>
             <span>Max left : <b id="mem_left">- MB</b></span>
             <span>Net In : <b id="net_in">‑ KB</b></span>
             <span>Net Out : <b id="net_out">‑ KB</b></span>
           `;
           document.body.appendChild(header);
         
           // 4. Conteneur écran
           const screenContainer = document.createElement("div");
           screenContainer.id = "screen_container";
           const screen = document.createElement("div");
           screen.id = "screen";
           const canvas = document.createElement("canvas");
           canvas.style.display = "none";
           screenContainer.appendChild(screen);
           screenContainer.appendChild(canvas);
           document.body.appendChild(screenContainer);
         
           // 5. Réseau global
           let netIn = 0, netOut = 0;
         
           // Instrumentation réseau
           (function(){
             const origFetch = window.fetch;
             window.fetch = async (...args) => {
               if (args[1]?.body) {
                 const b = args[1].body;
                 netOut += typeof b === 'string' ? b.length : (b.byteLength || 0);
               }
               const resp = await origFetch.apply(this, args);
             
               resp.clone().arrayBuffer().then(() => {
                 const entries = performance.getEntriesByType("resource")
                   .filter(e => e.name === resp.url);
                 if (entries.length) {
                   const last = entries[entries.length - 1];
                   // On compte uniquement si transferSize > 0 (réseau)
                   if (last.transferSize > 0) {
                     netIn += last.transferSize;
                   }
                 }
               }).catch(()=>{});
             
               return resp;
             };
         
             const origSend = XMLHttpRequest.prototype.send;
             XMLHttpRequest.prototype.send = function(body) {
               if(body) netOut += typeof body === 'string' ? body.length : (body.byteLength || 0);
               this.addEventListener('loadend', () => {
                 const entries = performance.getEntriesByType("resource")
                   .filter(e => e.name === this.responseURL);
                 if (entries.length) {
                   const last = entries[entries.length - 1];
                   if (last.transferSize > 0) {
                     netIn += last.transferSize;
                   }
                 }
               });
               return origSend.apply(this, arguments);
             };
         
             const OrigWS = window.WebSocket;
             window.WebSocket = function(url, protocols) {
               const ws = protocols ? new OrigWS(url, protocols) : new OrigWS(url);
               const origSend = ws.send;
               ws.send = function(data) {
                 let size = 0;
                 if (typeof data === 'string') size = new TextEncoder().encode(data).length;
                 else if (data instanceof Blob) size = data.size;
                 else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) size = data.byteLength;
                 netOut += size;
                 return origSend.call(this, data);
               };
               ws.addEventListener('message', event => {
                 const d = event.data;
                 let size = 0;
                 if (typeof d === 'string') size = new TextEncoder().encode(d).length;
                 else if (d instanceof Blob) size = d.size;
                 else if (d instanceof ArrayBuffer || ArrayBuffer.isView(d)) size = d.byteLength;
                 netIn += size;
               });
               return ws;
             };
             Object.assign(window.WebSocket, OrigWS);
             window.WebSocket.prototype = OrigWS.prototype;
           })();
         
            // ── Instrumentation mémoire (page-dirty) ──
            const pageSize   = 4096;
            const totalPages = MEMORY_SIZE / pageSize;
            const dirtyPages = new Uint8Array(totalPages);  // 0 = clean, 1 = dirty
            
           // 6. Monitoring immédiat
           async function updateStats() {
             const toMB = b => (b / 1024 / 1024).toFixed(1) + ' MB';
           
             let totalBytes = 0;
             let details = [];
           
             // 1) Si l’API expérimentale existe => on prend la mesure « native » Chrome
             if (performance.measureUserAgentSpecificMemory) {
               try {
                 const memInfo = await performance.measureUserAgentSpecificMemory();
                 // memInfo.bytes : total JS + DOM + WASM + GPU…
                 totalBytes = memInfo.bytes;
                 details.push(`Browser total: ${toMB(memInfo.bytes)}`);
               }
               catch (e) {
                 console.warn("measureUserAgentSpecificMemory failed:", e);
               }
             }
           
             // 2) Sinon (ou en plus), estimation manuelle :
             // 2.1 Heap JS
            let jsHeap = 0;
            if ('memory' in performance && performance.memory && typeof performance.memory.usedJSHeapSize === "number") {
                jsHeap = performance.memory.usedJSHeapSize;
            }
             details.push(`JS heap: ${toMB(jsHeap)}`);
           
             // 2.2 WASM (V86
            let wasmMem = 0;
            let ramDev;
            try {
                ramDev = emulator?.v86?.cpu?.mem8;
                if (ramDev?.buffer) {
                    wasmMem = ramDev.buffer.byteLength;
                }
            } catch (e) {
                wasmMem = 0;
            }
             if (ramDev) {
               const buf = ramDev.buffer;
               if (buf && typeof buf.byteLength === "number") {
                 wasmMem = buf.byteLength;
               }
               details.push(`WASM (V86): ${toMB(wasmMem)}`);
             }
           
             // 2.3 Canvas
             const canvasEl = document.querySelector("canvas");
             let canvasMem = 0;
             if (canvasEl && canvasEl.width && canvasEl.height) {
               canvasMem = canvasEl.width * canvasEl.height * 4;
               details.push(`Canvas RGBA: ${toMB(canvasMem)}`);
             }
           
             // Si on n'a pas eu measureUserAgentSpecificMemory, on fait la somme JS+WASM+Canvas
             if (!totalBytes) {
               totalBytes = jsHeap + wasmMem + canvasMem;
               details.unshift(`Estimated total: ${toMB(totalBytes)}`);
             } else {
               // on peut aussi afficher notre own breakdown en plus
               details.push(`Estimate breakdown: ${toMB(jsHeap)}+${toMB(wasmMem)}+${toMB(canvasMem)}`);
             }
             
             // calcul de l’espace réellement écrit dans les pages
             const freeBytes = Math.max(0, MEMORY_SIZE - fsWriteBytes);
             details.push(`FS used:  ${toMB(fsWriteBytes)}`);
             details.push(`FS free:  ${toMB(freeBytes)}`);
             
             // mise à jour de l’affichage
             
             document.getElementById('mem_ram').textContent = toMB(totalBytes);
             document.getElementById('mem_tooltip').textContent = details.join('\n');
         
             //document.getElementById('mem_left').textContent = toMB(freeBytes);
           
             document.getElementById('net_in').textContent  = (netIn  / 1024).toFixed(1) + ' KB';
             document.getElementById('net_out').textContent = (netOut / 1024).toFixed(1) + ' KB';
           }
         
           // 7. Charger les scripts externes puis lancer l’émulateur
           function loadScript(src) {
             return new Promise((resolve, reject) => {
               const s = document.createElement("script");
               s.src = src;
               s.onload = resolve;
               s.onerror = reject;
               document.body.appendChild(s);
             });
           }
         
           // 8. Lancement après chargement des libs
           async function launchEmulator() {
             await loadScript("build/pako.min.js");
             await loadScript("build/libv86.js");
             
             const v86Config = {
               wasm_path: "build/v86.wasm",
               bios: { url: "build/bios/seabios.bin" },
               vga_bios: { url: "build/bios/vgabios.bin" },
               memory_size: MEMORY_SIZE,
    bzimage:         { url: "vmlinuz"    },  
    initrd:         { url: "core.gz"      },
cmdline: "console=ttyS0,115200n8 init=/bin/sh",
//cmdline:       "quiet console=ttyS0,115200n8 root=/dev/ram0 rootfstype=tmpfs",
                serial_container: screenContainer,
               serial_read_only: true,
               screen_container: screenContainer,
               autostart: true,
               disable_memory_cow: true,
               worker: true, 
               network_relay_url: "wss://relay.widgetry.org",
               network_backend: "socket",
             };
           
window.emulator = emulator = new V86(v86Config);
              
             setInterval(updateStats, 500);
   
           // ── 1) Buffer pour stocker la sortie série ligne à ligne
           let serialBuf = "";
         
           // ── 2) Écouteur qui collecte les caractères envoyés par Linux
           emulator.add_listener("serial0-output-char", char => {
             serialBuf += char;
             if (char === "\n") {
               const line = serialBuf.trim();
               serialBuf = "";
               // On cherche la ligne “Mem:” de la commande free
               if (line.startsWith("Mem:")) {
                 // free -b affiche : Mem: TOTAL USED FREE ...
     const parts = line.split(/\s+/);
     // parts[6] = AVAILABLE (mémoire utilisable)
     const availableBytes = parseInt(parts[6], 10);
     document.getElementById("mem_left")
             .textContent = (availableBytes/1024/1024).toFixed(1) + " MB";
               }
             }
           });
         
           // ── 3) Toutes les 5 s, on envoie “free -b” dans la VM
           setInterval(() => {
             // la commande doit se terminer par \n pour être exécutée
             emulator.serial0_send("free -b\n");
           }, 5000);
          }
           launchEmulator();
         
         })();
      </script>
   </body>
</html>
