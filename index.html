<!DOCTYPE html>
<html lang="fr">
<head><meta charset="UTF-8"><title>Chargement...</title></head>
<body>
<script>
(function(){

  //const ISO = "TinyCore-current.iso";
  const ISO = "Core-current.iso";
  //const ISO = "slitaz-4.0-xorg-light-isohybrid.iso";

  // 1. Insérer style global
  const style = document.createElement("style");
  style.textContent = `
    html, body { background: black; margin:0; padding:0; color:#eee; font:12px monospace; }
    #header { position: fixed; top:0; left:0; width:100%; height:24px; background:#222; display:flex; align-items:center; z-index:1000; }
    #header span { margin:0 8px; }
    #screen_container { position:absolute; top:24px; left:0; width: 100vw; height:calc(100% - 24px);display: flex; }
    #screen { display: none; }
    #screen_container canvas {cursor:none; max-width:100%;max-height:100%;width:auto;height:auto;display:block;}
  `;

  document.head.appendChild(style);
  // 2. Titre
  document.title = "WASMSHELL";

  // 3. En-tête dynamique
  const header = document.createElement("div");
  header.id = "header";
  header.innerHTML = `
    <span>Memory : <b id="mem_ram">‑ MB</b></span>
    <span>Net In : <b id="net_in">‑ KB</b></span>
    <span>Net Out : <b id="net_out">‑ KB</b></span>
  `;
  document.body.appendChild(header);

  // 4. Conteneur écran
  const screenContainer = document.createElement("div");
  screenContainer.id = "screen_container";
  const screen = document.createElement("div");
  screen.id = "screen";
  const canvas = document.createElement("canvas");
  canvas.style.display = "none";
  screenContainer.appendChild(screen);
  screenContainer.appendChild(canvas);
  document.body.appendChild(screenContainer);

  // 5. Réseau global
  let netIn = 0, netOut = 0;

  // Instrumentation réseau
  (function(){
    const origFetch = window.fetch;
    window.fetch = async (...args) => {
      if (args[1]?.body) {
        const b = args[1].body;
        netOut += typeof b === 'string' ? b.length : (b.byteLength || 0);
      }
      const resp = await origFetch.apply(this, args);
    
      resp.clone().arrayBuffer().then(() => {
        const entries = performance.getEntriesByType("resource")
          .filter(e => e.name === resp.url);
        if (entries.length) {
          const last = entries[entries.length - 1];
          // On compte uniquement si transferSize > 0 (réseau)
          if (last.transferSize > 0) {
            netIn += last.transferSize;
          }
        }
      }).catch(()=>{});
    
      return resp;
    };

    const origSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(body) {
      if(body) netOut += typeof body === 'string' ? body.length : (body.byteLength || 0);
      this.addEventListener('loadend', () => {
        const entries = performance.getEntriesByType("resource")
          .filter(e => e.name === this.responseURL);
        if (entries.length) {
          const last = entries[entries.length - 1];
          if (last.transferSize > 0) {
            netIn += last.transferSize;
          }
        }
      });
      return origSend.apply(this, arguments);
    };

    const OrigWS = window.WebSocket;
    window.WebSocket = function(url, protocols) {
      const ws = protocols ? new OrigWS(url, protocols) : new OrigWS(url);
      const origSend = ws.send;
      ws.send = function(data) {
        let size = 0;
        if (typeof data === 'string') size = new TextEncoder().encode(data).length;
        else if (data instanceof Blob) size = data.size;
        else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) size = data.byteLength;
        netOut += size;
        return origSend.call(this, data);
      };
      ws.addEventListener('message', event => {
        const d = event.data;
        let size = 0;
        if (typeof d === 'string') size = new TextEncoder().encode(d).length;
        else if (d instanceof Blob) size = d.size;
        else if (d instanceof ArrayBuffer || ArrayBuffer.isView(d)) size = d.byteLength;
        netIn += size;
      });
      return ws;
    };
    Object.assign(window.WebSocket, OrigWS);
    window.WebSocket.prototype = OrigWS.prototype;
  })();

  // 6. Monitoring immédiat
  function updateStats() {
    const toMB = b => (b / 1024 / 1024).toFixed(1) + ' MB';
    const mem = performance.memory;
    if (mem) {
      const reserved = mem.usedJSHeapSize;
      const maximum = mem.jsHeapSizeLimit || 0;
      //document.getElementById('mem_ram').textContent = `${(reserved / 1024 / 1024).toFixed(1)} MB / ${(maximum / 1024 / 1024).toFixed(1)} MB`;
      document.getElementById('mem_ram').textContent = `${(reserved / 1024 / 1024).toFixed(1)} MB`;
    }
    document.getElementById('net_in').textContent  = (netIn  / 1024).toFixed(1) + ' KB';
    document.getElementById('net_out').textContent = (netOut / 1024).toFixed(1) + ' KB';
  }
  setInterval(updateStats, 1000);
  updateStats();

  // 7. Charger les scripts externes puis lancer l’émulateur
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src;
      s.onload = resolve;
      s.onerror = reject;
      document.body.appendChild(s);
    });
  }

  // 8. Lancement après chargement des libs
  async function launchEmulator() {
    await loadScript("build/pako.min.js");
    await loadScript("build/libv86.js");

    const MEMORY_SIZE = 256 * 1024 * 1024;

    new V86({
      wasm_path: "build/v86.wasm",
      bios: { url: "build/bios/seabios.bin" },
      vga_bios: { url: "build/bios/vgabios.bin" },
      memory_size: MEMORY_SIZE,
      cdrom: { url: ISO },
      screen_container: screenContainer,
      autostart: true,
      disable_memory_cow: true,
      network_relay_url: "wss://relay.widgetry.org",
      network_backend: "socket",
    });
  }

  launchEmulator();

})();
</script>
</body>
</html>

